#include <engine/graphics/renderer/NrcHpmRenderer.hpp>
#include <engine/graphics/VulkanAPI.hpp>
#include <engine/graphics/vulkan/CommandRecorder.hpp>
//#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>
#include <engine/util/openexr_helper.hpp>

namespace en
{
    VkDescriptorSetLayout NrcHpmRenderer::m_DescriptorSetLayout;
    VkDescriptorPool NrcHpmRenderer::m_DescriptorPool;

    void NrcHpmRenderer::Init(VkDevice device)
    {
        // Create descriptor set layout;
        VkDescriptorSetLayoutBinding lowPassImageBinding;
        lowPassImageBinding.binding = 0;
        lowPassImageBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        lowPassImageBinding.descriptorCount = 1;
        lowPassImageBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
        lowPassImageBinding.pImmutableSamplers = nullptr;

        std::vector<VkDescriptorSetLayoutBinding> bindings = { lowPassImageBinding };

        VkDescriptorSetLayoutCreateInfo layoutCI;
        layoutCI.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
        layoutCI.pNext = nullptr;
        layoutCI.flags = 0;
        layoutCI.bindingCount = bindings.size();
        layoutCI.pBindings = bindings.data();

        VkResult result = vkCreateDescriptorSetLayout(device, &layoutCI, nullptr, &m_DescriptorSetLayout);
        ASSERT_VULKAN(result);

        // Create descriptor pool
        VkDescriptorPoolSize lowPassImagePoolSize;
        lowPassImagePoolSize.type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        lowPassImagePoolSize.descriptorCount = 1;

        std::vector<VkDescriptorPoolSize> poolSizes = { lowPassImagePoolSize };

        VkDescriptorPoolCreateInfo poolCI;
        poolCI.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        poolCI.pNext = nullptr;
        poolCI.flags = 0;
        poolCI.maxSets = 1;
        poolCI.poolSizeCount = poolSizes.size();
        poolCI.pPoolSizes = poolSizes.data();

        result = vkCreateDescriptorPool(device, &poolCI, nullptr, &m_DescriptorPool);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::Shutdown(VkDevice device)
    {
        vkDestroyDescriptorPool(device, m_DescriptorPool, nullptr);
        vkDestroyDescriptorSetLayout(device, m_DescriptorSetLayout, nullptr);
    }

    NrcHpmRenderer::NrcHpmRenderer(
            uint32_t width,
            uint32_t height,
            float trainPortion,
            const Camera& camera,
            const VolumeData& volumeData,
            const DirLight& dirLight,
            const PointLight& pointLight)
            :
            m_FrameWidth(width),
            m_FrameHeight(height),
            m_TrainScale(std::sqrt(trainPortion)),
            m_TrainWidth(static_cast<uint32_t>(m_TrainScale * width)),
            m_TrainHeight(static_cast<uint32_t>(m_TrainScale * height)),
            m_VertShader("path-tracer/path-tracer.vert", false),
            m_FragShader("path-tracer/path-tracer.frag", false),
            m_CommandPool(0, VulkanAPI::GetGraphicsQFI()),
            m_Camera(camera),
            m_VolumeData(volumeData),
            m_DirLight(dirLight),
            m_PointLight(pointLight)
    {
        VkDevice device = VulkanAPI::GetDevice();

        CreateRenderPass(device);
        CreatePipelineLayout(device);
        CreatePipeline(device);
        CreateColorImage(device);
        CreateTrainImage(device);
        CreatePosImage(device);
        CreateDirImage(device);
        CreateLowPassResources(device);
        CreateLowPassImage(device);
        CreateFramebuffer(device);

        m_CommandPool.AllocateBuffers(1, VK_COMMAND_BUFFER_LEVEL_PRIMARY);
        m_CommandBuffer = m_CommandPool.GetBuffer(0);

        RecordCommandBuffer();
    }

    void NrcHpmRenderer::Render(VkQueue queue) const
    {
        VkSubmitInfo submitInfo;
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.pNext = nullptr;
        submitInfo.waitSemaphoreCount = 0;
        submitInfo.pWaitSemaphores = nullptr;
        submitInfo.pWaitDstStageMask = nullptr;
        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &m_CommandBuffer;
        submitInfo.signalSemaphoreCount = 0;
        submitInfo.pSignalSemaphores = nullptr;

        VkResult result = vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::Destroy()
    {
        VkDevice device = VulkanAPI::GetDevice();

        m_CommandPool.Destroy();
        vkDestroyFramebuffer(device, m_Framebuffer, nullptr);

        vkDestroyImageView(device, m_DirImageView, nullptr);
        vkFreeMemory(device, m_DirImageMemory, nullptr);
        vkDestroyImage(device, m_DirImage, nullptr);

        vkDestroyImageView(device, m_PosImageView, nullptr);
        vkFreeMemory(device, m_PosImageMemory, nullptr);
        vkDestroyImage(device, m_PosImage, nullptr);

        vkDestroySampler(device, m_LowPassSampler, nullptr);
        vkDestroyImageView(device, m_LowPassImageView, nullptr);
        vkFreeMemory(device, m_LowPassImageMemory, nullptr);
        vkDestroyImage(device, m_LowPassImage, nullptr);

        vkDestroyImageView(device, m_TrainImageView, nullptr);
        vkFreeMemory(device, m_TrainImageMemory, nullptr);
        vkDestroyImage(device, m_TrainImage, nullptr);

        vkDestroyImageView(device, m_ColorImageView, nullptr);
        vkFreeMemory(device, m_ColorImageMemory, nullptr);
        vkDestroyImage(device, m_ColorImage, nullptr);

        vkDestroyPipelineLayout(device, m_PipelineLayout, nullptr);
        vkDestroyPipeline(device, m_Pipeline, nullptr);
        m_VertShader.Destroy();
        m_FragShader.Destroy();
        vkDestroyRenderPass(device, m_RenderPass, nullptr);
    }

    void NrcHpmRenderer::ResizeFrame(uint32_t width, uint32_t height)
    {
        m_FrameWidth = width;
        m_FrameHeight = height;

        m_TrainWidth = static_cast<uint32_t>(m_TrainScale * width);
        m_TrainHeight = static_cast<uint32_t>(m_TrainScale * height);

        Log::Info("Train pixels " + std::to_string(m_TrainWidth * m_TrainHeight));

        VkDevice device = VulkanAPI::GetDevice();

        // Destroy
        m_CommandPool.FreeBuffers();
        vkDestroyFramebuffer(device, m_Framebuffer, nullptr);

        vkDestroyImageView(device, m_DirImageView, nullptr);
        vkFreeMemory(device, m_DirImageMemory, nullptr);
        vkDestroyImage(device, m_DirImage, nullptr);

        vkDestroyImageView(device, m_PosImageView, nullptr);
        vkFreeMemory(device, m_PosImageMemory, nullptr);
        vkDestroyImage(device, m_PosImage, nullptr);

        vkDestroyImageView(device, m_LowPassImageView, nullptr);
        vkFreeMemory(device, m_LowPassImageMemory, nullptr);
        vkDestroyImage(device, m_LowPassImage, nullptr);

        vkDestroyImageView(device, m_TrainImageView, nullptr);
        vkFreeMemory(device, m_TrainImageMemory, nullptr);
        vkDestroyImage(device, m_TrainImage, nullptr);

        vkDestroyImageView(device, m_ColorImageView, nullptr);
        vkFreeMemory(device, m_ColorImageMemory, nullptr);
        vkDestroyImage(device, m_ColorImage, nullptr);

        // Create
        CreateColorImage(device);
        CreateTrainImage(device);
        CreatePosImage(device);
        CreateDirImage(device);
        CreateLowPassImage(device);
        CreateFramebuffer(device);

        m_CommandPool.AllocateBuffers(1, VK_COMMAND_BUFFER_LEVEL_PRIMARY);
        m_CommandBuffer = m_CommandPool.GetBuffer(0);

        RecordCommandBuffer();
    }

    void NrcHpmRenderer::ExportImageToHost(VkQueue queue, uint64_t index)
    {
        //
        VkDeviceSize colorSize = GetImageDataSize();
        vk::Buffer colorBuffer(
                colorSize,
                VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
                VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                {});

        VkDeviceSize posSize = colorSize * 4; // sizeof(float) = 4
        vk::Buffer posBuffer(posSize,
                             VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
                             VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                             {});

        VkDeviceSize dirSize = colorSize * 4; // TODO: / 2
        vk::Buffer dirBuffer(dirSize,
                             VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
                             VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                             {});

        //
        vk::CommandPool commandPool(0, VulkanAPI::GetGraphicsQFI());
        commandPool.AllocateBuffers(1, VK_COMMAND_BUFFER_LEVEL_PRIMARY);
        VkCommandBuffer commandBuffer = commandPool.GetBuffer(0);

        // Begin
        VkCommandBufferBeginInfo beginInfo;
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.pNext = nullptr;
        beginInfo.flags = 0;
        beginInfo.pInheritanceInfo = nullptr;

        VkResult result = vkBeginCommandBuffer(commandBuffer, &beginInfo);
        if (result != VK_SUCCESS)
            Log::Error("Failed to begin VkCommandBuffer", true);

        // Copy color
        VkBufferImageCopy colorRegion;
        colorRegion.bufferOffset = 0;
        colorRegion.bufferRowLength = m_FrameWidth;
        colorRegion.bufferImageHeight = m_FrameHeight;
        colorRegion.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        colorRegion.imageSubresource.mipLevel = 0;
        colorRegion.imageSubresource.baseArrayLayer = 0;
        colorRegion.imageSubresource.layerCount = 1;
        colorRegion.imageOffset = { 0, 0, 0 };
        colorRegion.imageExtent = { m_FrameWidth, m_FrameHeight, 1 };

        vkCmdCopyImageToBuffer(
                commandBuffer,
                m_ColorImage,
                VK_IMAGE_LAYOUT_GENERAL,
                colorBuffer.GetVulkanHandle(),
                1,
                &colorRegion);

        // Pos color
        VkBufferImageCopy posRegion;
        posRegion.bufferOffset = 0;
        posRegion.bufferRowLength = m_FrameWidth;
        posRegion.bufferImageHeight = m_FrameHeight;
        posRegion.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        posRegion.imageSubresource.mipLevel = 0;
        posRegion.imageSubresource.baseArrayLayer = 0;
        posRegion.imageSubresource.layerCount = 1;
        posRegion.imageOffset = { 0, 0, 0 };
        posRegion.imageExtent = { m_FrameWidth, m_FrameHeight, 1 };

        vkCmdCopyImageToBuffer(
                commandBuffer,
                m_PosImage,
                VK_IMAGE_LAYOUT_GENERAL,
                posBuffer.GetVulkanHandle(),
                1,
                &posRegion);

        // Dir color
        VkBufferImageCopy dirRegion;
        dirRegion.bufferOffset = 0;
        dirRegion.bufferRowLength = m_FrameWidth;
        dirRegion.bufferImageHeight = m_FrameHeight;
        dirRegion.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        dirRegion.imageSubresource.mipLevel = 0;
        dirRegion.imageSubresource.baseArrayLayer = 0;
        dirRegion.imageSubresource.layerCount = 1;
        dirRegion.imageOffset = { 0, 0, 0 };
        dirRegion.imageExtent = { m_FrameWidth, m_FrameHeight, 1 };

        vkCmdCopyImageToBuffer(
                commandBuffer,
                m_DirImage,
                VK_IMAGE_LAYOUT_GENERAL,
                dirBuffer.GetVulkanHandle(),
                1,
                &dirRegion);

        // End
        result = vkEndCommandBuffer(commandBuffer);
        if (result != VK_SUCCESS)
            Log::Error("Failed to end VkCommandBuffer", true);

        // Submit
        VkSubmitInfo submitInfo;
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.pNext = nullptr;
        submitInfo.waitSemaphoreCount = 0;
        submitInfo.pWaitSemaphores = nullptr;
        submitInfo.pWaitDstStageMask = nullptr;
        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &commandBuffer;
        submitInfo.signalSemaphoreCount = 0;
        submitInfo.pSignalSemaphores = nullptr;

        result = vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
        ASSERT_VULKAN(result);

        result = vkQueueWaitIdle(queue);
        ASSERT_VULKAN(result);

        //
        void* colorData = malloc(colorSize);
        colorBuffer.GetData(colorSize, colorData, 0, 0);

        void* posData = malloc(posSize);
        posBuffer.GetData(posSize, posData, 0, 0);

        void* dirData = malloc(dirSize);
        dirBuffer.GetData(dirSize, dirData, 0, 0);

        //
        commandPool.Destroy();
        colorBuffer.Destroy();
        posBuffer.Destroy();
        dirBuffer.Destroy();

        //
        std::string path = "data/output/";
        std::string endStr = std::to_string(index);

        std::string colorStr = path + "color/" + endStr + ".exr";
        std::string posStr = path + "pos/" + endStr + ".exr";
        std::string dirStr = path + "dir/" + endStr + ".exr";

        // Convert color to f32
        float* colorFData = reinterpret_cast<float*>(malloc(m_FrameWidth * m_FrameHeight * 4 * sizeof(float)));
        for (size_t i = 0; i < m_FrameWidth * m_FrameHeight * 4; i++)
        {
            colorFData[i] = static_cast<float>(reinterpret_cast<uint8_t*>(colorData)[i]) / 255.0f;
        }

        WriteEXR(colorStr.c_str(), colorFData, m_FrameWidth, m_FrameHeight);
        WriteEXR(posStr.c_str(), reinterpret_cast<float*>(posData), m_FrameWidth, m_FrameHeight);
        WriteEXR(dirStr.c_str(), reinterpret_cast<float*>(dirData), m_FrameWidth, m_FrameHeight);

        free(colorData);
        free(posData);
        free(dirData);
        free(colorFData);
    }

    VkImage NrcHpmRenderer::GetImage() const
    {
        return m_ColorImage;
    }

    VkImageView NrcHpmRenderer::GetImageView() const
    {
        return m_ColorImageView;
    }

    size_t NrcHpmRenderer::GetImageDataSize() const
    {
        // Dependent on format
        return m_FrameWidth * m_FrameHeight * 4;
    }

    void NrcHpmRenderer::CreateRenderPass(VkDevice device)
    {
        // Color attachment
        VkAttachmentDescription colorAtt;
        colorAtt.flags = 0;
        colorAtt.format = VulkanAPI::GetSurfaceFormat().format;
        colorAtt.samples = VK_SAMPLE_COUNT_1_BIT;
        colorAtt.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        colorAtt.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
        colorAtt.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        colorAtt.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
        colorAtt.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        colorAtt.finalLayout = VK_IMAGE_LAYOUT_GENERAL;

        VkAttachmentReference colorAttRef;
        colorAttRef.attachment = 0;
        colorAttRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        // Pos attachment
        VkAttachmentDescription posAtt;
        posAtt.flags = 0;
        posAtt.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        posAtt.samples = VK_SAMPLE_COUNT_1_BIT;
        posAtt.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        posAtt.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
        posAtt.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        posAtt.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
        posAtt.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        posAtt.finalLayout = VK_IMAGE_LAYOUT_GENERAL;

        VkAttachmentReference posAttRef;
        posAttRef.attachment = 1;
        posAttRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        // Dir attachment
        VkAttachmentDescription dirAtt;
        dirAtt.flags = 0;
        dirAtt.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        dirAtt.samples = VK_SAMPLE_COUNT_1_BIT;
        dirAtt.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        dirAtt.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
        dirAtt.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        dirAtt.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
        dirAtt.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        dirAtt.finalLayout = VK_IMAGE_LAYOUT_GENERAL;

        VkAttachmentReference dirAttRef;
        dirAttRef.attachment = 2;
        dirAttRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        std::vector<VkAttachmentReference> colorAttRefs = { colorAttRef, posAttRef, dirAttRef };

        VkSubpassDescription subpass;
        subpass.flags = 0;
        subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
        subpass.inputAttachmentCount = 0;
        subpass.pInputAttachments = nullptr;
        subpass.colorAttachmentCount = colorAttRefs.size();
        subpass.pColorAttachments = colorAttRefs.data();
        subpass.pResolveAttachments = nullptr;
        subpass.pDepthStencilAttachment = nullptr;
        subpass.preserveAttachmentCount = 0;
        subpass.pPreserveAttachments = nullptr;

        VkSubpassDependency subpassDependency;
        subpassDependency.srcSubpass = VK_SUBPASS_EXTERNAL;
        subpassDependency.dstSubpass = 0;
        subpassDependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        subpassDependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        subpassDependency.srcAccessMask = 0;
        subpassDependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
        subpassDependency.dependencyFlags = 0;

        std::vector<VkAttachmentDescription> attachments = { colorAtt, posAtt, dirAtt };

        VkRenderPassCreateInfo createInfo;
        createInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
        createInfo.pNext = nullptr;
        createInfo.flags = 0;
        createInfo.attachmentCount = attachments.size();
        createInfo.pAttachments = attachments.data();
        createInfo.subpassCount = 1;
        createInfo.pSubpasses = &subpass;
        createInfo.dependencyCount = 1;
        createInfo.pDependencies = &subpassDependency;

        VkResult result = vkCreateRenderPass(device, &createInfo, nullptr, &m_RenderPass);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreatePipelineLayout(VkDevice device)
    {
        std::vector<VkDescriptorSetLayout> layouts = {
                Camera::GetDescriptorSetLayout(),
                VolumeData::GetDescriptorSetLayout(),
                DirLight::GetDescriptorSetLayout(),
                PointLight::GetDescriptorSetLayout(),
                m_DescriptorSetLayout };

        VkPipelineLayoutCreateInfo layoutCreateInfo;
        layoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
        layoutCreateInfo.pNext = nullptr;
        layoutCreateInfo.flags = 0;
        layoutCreateInfo.setLayoutCount = layouts.size();
        layoutCreateInfo.pSetLayouts = layouts.data();
        layoutCreateInfo.pushConstantRangeCount = 0;
        layoutCreateInfo.pPushConstantRanges = nullptr;

        VkResult result = vkCreatePipelineLayout(device, &layoutCreateInfo, nullptr, &m_PipelineLayout);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreatePipeline(VkDevice device)
    {
        // Shader stage
        VkPipelineShaderStageCreateInfo vertStageCreateInfo;
        vertStageCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        vertStageCreateInfo.pNext = nullptr;
        vertStageCreateInfo.flags = 0;
        vertStageCreateInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
        vertStageCreateInfo.module = m_VertShader.GetVulkanModule();
        vertStageCreateInfo.pName = "main";
        vertStageCreateInfo.pSpecializationInfo = nullptr;

        VkPipelineShaderStageCreateInfo fragStageCreateInfo;
        fragStageCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        fragStageCreateInfo.pNext = nullptr;
        fragStageCreateInfo.flags = 0;
        fragStageCreateInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
        fragStageCreateInfo.module = m_FragShader.GetVulkanModule();
        fragStageCreateInfo.pName = "main";
        fragStageCreateInfo.pSpecializationInfo = nullptr;

        std::vector<VkPipelineShaderStageCreateInfo> shaderStages = { vertStageCreateInfo, fragStageCreateInfo };

        // Vertex input
        VkPipelineVertexInputStateCreateInfo vertexInputCreateInfo;
        vertexInputCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
        vertexInputCreateInfo.pNext = nullptr;
        vertexInputCreateInfo.flags = 0;
        vertexInputCreateInfo.vertexBindingDescriptionCount = 0;
        vertexInputCreateInfo.pVertexBindingDescriptions = nullptr;
        vertexInputCreateInfo.vertexAttributeDescriptionCount = 0;
        vertexInputCreateInfo.pVertexAttributeDescriptions = nullptr;

        // Input assembly
        VkPipelineInputAssemblyStateCreateInfo inputAssemblyCreateInfo;
        inputAssemblyCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
        inputAssemblyCreateInfo.pNext = nullptr;
        inputAssemblyCreateInfo.flags = 0;
        inputAssemblyCreateInfo.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        inputAssemblyCreateInfo.primitiveRestartEnable = VK_FALSE;

        // Viewports and scissors
        VkViewport viewport;
        viewport.x = 0.0f;
        viewport.y = 0.0f;
        viewport.width = static_cast<float>(m_FrameWidth);
        viewport.height = static_cast<float>(m_FrameHeight);
        viewport.minDepth = 0.0f;
        viewport.maxDepth = 1.0f;

        VkRect2D scissor;
        scissor.offset = { 0, 0 };
        scissor.extent = { m_FrameWidth, m_FrameHeight };

        VkPipelineViewportStateCreateInfo viewportCreateInfo;
        viewportCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
        viewportCreateInfo.pNext = nullptr;
        viewportCreateInfo.flags = 0;
        viewportCreateInfo.viewportCount = 1;
        viewportCreateInfo.pViewports = &viewport;
        viewportCreateInfo.scissorCount = 1;
        viewportCreateInfo.pScissors = &scissor;

        // Rasterizer
        VkPipelineRasterizationStateCreateInfo rasterizerCreateInfo;
        rasterizerCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
        rasterizerCreateInfo.pNext = nullptr;
        rasterizerCreateInfo.flags = 0;
        rasterizerCreateInfo.depthClampEnable = VK_FALSE;
        rasterizerCreateInfo.rasterizerDiscardEnable = VK_FALSE;
        rasterizerCreateInfo.polygonMode = VK_POLYGON_MODE_FILL;
        rasterizerCreateInfo.cullMode = VK_CULL_MODE_BACK_BIT;
        rasterizerCreateInfo.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
        rasterizerCreateInfo.depthBiasEnable = VK_FALSE;
        rasterizerCreateInfo.depthBiasConstantFactor = 0.0f;
        rasterizerCreateInfo.depthBiasClamp = 0.0f;
        rasterizerCreateInfo.depthBiasSlopeFactor = 0.0f;
        rasterizerCreateInfo.lineWidth = 1.0f;

        // Multisampling
        VkPipelineMultisampleStateCreateInfo multisampleCreateInfo;
        multisampleCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
        multisampleCreateInfo.pNext = nullptr;
        multisampleCreateInfo.flags = 0;
        multisampleCreateInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
        multisampleCreateInfo.sampleShadingEnable = VK_FALSE;
        multisampleCreateInfo.minSampleShading = 1.0f;
        multisampleCreateInfo.pSampleMask = nullptr;
        multisampleCreateInfo.alphaToCoverageEnable = VK_FALSE;
        multisampleCreateInfo.alphaToOneEnable = VK_FALSE;

        // Depth and stencil testing
        /*VkPipelineDepthStencilStateCreateInfo depthStencilCreateInfo; // TODO
        depthStencilCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
        depthStencilCreateInfo.pNext = nullptr;
        depthStencilCreateInfo.flags = 0;
        depthStencilCreateInfo.depthTestEnable = VK_FALSE;
        depthStencilCreateInfo.depthWriteEnable = VK_FALSE;
        depthStencilCreateInfo.depthCompareOp = VK_COMPARE_OP_LESS;
        depthStencilCreateInfo.depthBoundsTestEnable = VK_FALSE;
        depthStencilCreateInfo.stencilTestEnable = VK_FALSE;
        depthStencilCreateInfo.front;
        depthStencilCreateInfo.back;
        depthStencilCreateInfo.minDepthBounds;
        depthStencilCreateInfo.maxDepthBounds;*/

        // Color blending
        VkPipelineColorBlendAttachmentState colorBlendAttachment;
        colorBlendAttachment.blendEnable = VK_FALSE;
        colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
        colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
        colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
        colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
        colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
        colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;
        colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;

        // Color blending
        VkPipelineColorBlendAttachmentState posBlendAttachment;
        posBlendAttachment.blendEnable = VK_FALSE;
        posBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
        posBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
        posBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
        posBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
        posBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
        posBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;
        posBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;

        // Color blending
        VkPipelineColorBlendAttachmentState dirBlendAttachment;
        dirBlendAttachment.blendEnable = VK_FALSE;
        dirBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
        dirBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
        dirBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
        dirBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
        dirBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
        dirBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;
        dirBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;

        std::vector<VkPipelineColorBlendAttachmentState> colorBlendAttStates = { colorBlendAttachment, posBlendAttachment, dirBlendAttachment };

        VkPipelineColorBlendStateCreateInfo colorBlendCreateInfo;
        colorBlendCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
        colorBlendCreateInfo.pNext = nullptr;
        colorBlendCreateInfo.flags = 0;
        colorBlendCreateInfo.logicOpEnable = VK_FALSE;
        colorBlendCreateInfo.logicOp = VK_LOGIC_OP_COPY;
        colorBlendCreateInfo.attachmentCount = colorBlendAttStates.size();
        colorBlendCreateInfo.pAttachments = colorBlendAttStates.data();
        colorBlendCreateInfo.blendConstants[0] = 0.0f;
        colorBlendCreateInfo.blendConstants[1] = 0.0f;
        colorBlendCreateInfo.blendConstants[2] = 0.0f;
        colorBlendCreateInfo.blendConstants[3] = 0.0f;

        // Dynamic states
        std::vector<VkDynamicState> dynamicStates = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };

        VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo;
        dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
        dynamicStateCreateInfo.pNext = nullptr;
        dynamicStateCreateInfo.flags = 0;
        dynamicStateCreateInfo.dynamicStateCount = dynamicStates.size();
        dynamicStateCreateInfo.pDynamicStates = dynamicStates.data();

        // Creation
        VkGraphicsPipelineCreateInfo createInfo;
        createInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
        createInfo.pNext = nullptr;
        createInfo.flags = 0;
        createInfo.stageCount = shaderStages.size();
        createInfo.pStages = shaderStages.data();
        createInfo.pVertexInputState = &vertexInputCreateInfo;
        createInfo.pInputAssemblyState = &inputAssemblyCreateInfo;
        createInfo.pTessellationState = nullptr;
        createInfo.pViewportState = &viewportCreateInfo;
        createInfo.pRasterizationState = &rasterizerCreateInfo;
        createInfo.pMultisampleState = &multisampleCreateInfo;
        createInfo.pDepthStencilState = nullptr; // TODO
        createInfo.pColorBlendState = &colorBlendCreateInfo;
        createInfo.pDynamicState = &dynamicStateCreateInfo;
        createInfo.layout = m_PipelineLayout;
        createInfo.renderPass = m_RenderPass;
        createInfo.subpass = 0;
        createInfo.basePipelineHandle = VK_NULL_HANDLE;
        createInfo.basePipelineIndex = -1;

        VkResult result = vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &createInfo, nullptr, &m_Pipeline);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreateColorImage(VkDevice device)
    {
        // Create Image
        VkImageCreateInfo imageCI;
        imageCI.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        imageCI.pNext = nullptr;
        imageCI.flags = 0;
        imageCI.imageType = VK_IMAGE_TYPE_2D;
        imageCI.format = VulkanAPI::GetSurfaceFormat().format;
        imageCI.extent = { m_FrameWidth, m_FrameHeight, 1 };
        imageCI.mipLevels = 1;
        imageCI.arrayLayers = 1;
        imageCI.samples = VK_SAMPLE_COUNT_1_BIT;
        imageCI.tiling = VK_IMAGE_TILING_OPTIMAL;
        imageCI.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
        imageCI.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        imageCI.queueFamilyIndexCount = 0;
        imageCI.pQueueFamilyIndices = nullptr;
        imageCI.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; // TODO: maybe?

        VkResult result = vkCreateImage(device, &imageCI, nullptr, &m_ColorImage);
        ASSERT_VULKAN(result);

        // Image Memory
        VkMemoryRequirements memoryRequirements;
        vkGetImageMemoryRequirements(device, m_ColorImage, &memoryRequirements);

        VkMemoryAllocateInfo allocateInfo;
        allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        allocateInfo.pNext = nullptr;
        allocateInfo.allocationSize = memoryRequirements.size;
        allocateInfo.memoryTypeIndex = VulkanAPI::FindMemoryType(
                memoryRequirements.memoryTypeBits,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

        result = vkAllocateMemory(device, &allocateInfo, nullptr, &m_ColorImageMemory);
        ASSERT_VULKAN(result);

        result = vkBindImageMemory(device, m_ColorImage, m_ColorImageMemory, 0);
        ASSERT_VULKAN(result);

        // Create image view
        VkImageViewCreateInfo imageViewCI;
        imageViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        imageViewCI.pNext = nullptr;
        imageViewCI.flags = 0;
        imageViewCI.image = m_ColorImage;
        imageViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
        imageViewCI.format = VulkanAPI::GetSurfaceFormat().format;
        imageViewCI.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageViewCI.subresourceRange.baseMipLevel = 0;
        imageViewCI.subresourceRange.levelCount = 1;
        imageViewCI.subresourceRange.baseArrayLayer = 0;
        imageViewCI.subresourceRange.layerCount = 1;

        result = vkCreateImageView(device, &imageViewCI, nullptr, &m_ColorImageView);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreateTrainImage(VkDevice device)
    {
        // Create Image
        VkImageCreateInfo imageCI;
        imageCI.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        imageCI.pNext = nullptr;
        imageCI.flags = 0;
        imageCI.imageType = VK_IMAGE_TYPE_2D;
        imageCI.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        imageCI.extent = { m_TrainWidth, m_TrainHeight, 1 };
        imageCI.mipLevels = 1;
        imageCI.arrayLayers = 1;
        imageCI.samples = VK_SAMPLE_COUNT_1_BIT;
        imageCI.tiling = VK_IMAGE_TILING_OPTIMAL;
        imageCI.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
        imageCI.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        imageCI.queueFamilyIndexCount = 0;
        imageCI.pQueueFamilyIndices = nullptr;
        imageCI.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; // TODO: maybe?

        VkResult result = vkCreateImage(device, &imageCI, nullptr, &m_TrainImage);
        ASSERT_VULKAN(result);

        // Image Memory
        VkMemoryRequirements memoryRequirements;
        vkGetImageMemoryRequirements(device, m_TrainImage, &memoryRequirements);

        VkMemoryAllocateInfo allocateInfo;
        allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        allocateInfo.pNext = nullptr;
        allocateInfo.allocationSize = memoryRequirements.size;
        allocateInfo.memoryTypeIndex = VulkanAPI::FindMemoryType(
                memoryRequirements.memoryTypeBits,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

        result = vkAllocateMemory(device, &allocateInfo, nullptr, &m_TrainImageMemory);
        ASSERT_VULKAN(result);

        result = vkBindImageMemory(device, m_TrainImage, m_TrainImageMemory, 0);
        ASSERT_VULKAN(result);

        // Create image view
        VkImageViewCreateInfo imageViewCI;
        imageViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        imageViewCI.pNext = nullptr;
        imageViewCI.flags = 0;
        imageViewCI.image = m_TrainImage;
        imageViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
        imageViewCI.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        imageViewCI.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageViewCI.subresourceRange.baseMipLevel = 0;
        imageViewCI.subresourceRange.levelCount = 1;
        imageViewCI.subresourceRange.baseArrayLayer = 0;
        imageViewCI.subresourceRange.layerCount = 1;

        result = vkCreateImageView(device, &imageViewCI, nullptr, &m_TrainImageView);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreatePosImage(VkDevice device)
    {
        // Create Image
        VkImageCreateInfo imageCI;
        imageCI.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        imageCI.pNext = nullptr;
        imageCI.flags = 0;
        imageCI.imageType = VK_IMAGE_TYPE_2D;
        imageCI.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        imageCI.extent = { m_FrameWidth, m_FrameHeight, 1 };
        imageCI.mipLevels = 1;
        imageCI.arrayLayers = 1;
        imageCI.samples = VK_SAMPLE_COUNT_1_BIT;
        imageCI.tiling = VK_IMAGE_TILING_OPTIMAL;
        imageCI.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
        imageCI.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        imageCI.queueFamilyIndexCount = 0;
        imageCI.pQueueFamilyIndices = nullptr;
        imageCI.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

        VkResult result = vkCreateImage(device, &imageCI, nullptr, &m_PosImage);
        ASSERT_VULKAN(result);

        // Image Memory
        VkMemoryRequirements memoryRequirements;
        vkGetImageMemoryRequirements(device, m_PosImage, &memoryRequirements);

        VkMemoryAllocateInfo allocateInfo;
        allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        allocateInfo.pNext = nullptr;
        allocateInfo.allocationSize = memoryRequirements.size;
        allocateInfo.memoryTypeIndex = VulkanAPI::FindMemoryType(
                memoryRequirements.memoryTypeBits,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

        result = vkAllocateMemory(device, &allocateInfo, nullptr, &m_PosImageMemory);
        ASSERT_VULKAN(result);

        result = vkBindImageMemory(device, m_PosImage, m_PosImageMemory, 0);
        ASSERT_VULKAN(result);

        // Create image view
        VkImageViewCreateInfo imageViewCI;
        imageViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        imageViewCI.pNext = nullptr;
        imageViewCI.flags = 0;
        imageViewCI.image = m_PosImage;
        imageViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
        imageViewCI.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        imageViewCI.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageViewCI.subresourceRange.baseMipLevel = 0;
        imageViewCI.subresourceRange.levelCount = 1;
        imageViewCI.subresourceRange.baseArrayLayer = 0;
        imageViewCI.subresourceRange.layerCount = 1;

        result = vkCreateImageView(device, &imageViewCI, nullptr, &m_PosImageView);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreateDirImage(VkDevice device)
    {
        // Create Image
        VkImageCreateInfo imageCI;
        imageCI.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        imageCI.pNext = nullptr;
        imageCI.flags = 0;
        imageCI.imageType = VK_IMAGE_TYPE_2D;
        imageCI.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        imageCI.extent = { m_FrameWidth, m_FrameHeight, 1 };
        imageCI.mipLevels = 1;
        imageCI.arrayLayers = 1;
        imageCI.samples = VK_SAMPLE_COUNT_1_BIT;
        imageCI.tiling = VK_IMAGE_TILING_OPTIMAL;
        imageCI.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
        imageCI.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        imageCI.queueFamilyIndexCount = 0;
        imageCI.pQueueFamilyIndices = nullptr;
        imageCI.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

        VkResult result = vkCreateImage(device, &imageCI, nullptr, &m_DirImage);
        ASSERT_VULKAN(result);

        // Image Memory
        VkMemoryRequirements memoryRequirements;
        vkGetImageMemoryRequirements(device, m_DirImage, &memoryRequirements);

        VkMemoryAllocateInfo allocateInfo;
        allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        allocateInfo.pNext = nullptr;
        allocateInfo.allocationSize = memoryRequirements.size;
        allocateInfo.memoryTypeIndex = VulkanAPI::FindMemoryType(
                memoryRequirements.memoryTypeBits,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

        result = vkAllocateMemory(device, &allocateInfo, nullptr, &m_DirImageMemory);
        ASSERT_VULKAN(result);

        result = vkBindImageMemory(device, m_DirImage, m_DirImageMemory, 0);
        ASSERT_VULKAN(result);

        // Create image view
        VkImageViewCreateInfo imageViewCI;
        imageViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        imageViewCI.pNext = nullptr;
        imageViewCI.flags = 0;
        imageViewCI.image = m_DirImage;
        imageViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
        imageViewCI.format = VK_FORMAT_R32G32B32A32_SFLOAT;
        imageViewCI.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageViewCI.subresourceRange.baseMipLevel = 0;
        imageViewCI.subresourceRange.levelCount = 1;
        imageViewCI.subresourceRange.baseArrayLayer = 0;
        imageViewCI.subresourceRange.layerCount = 1;

        result = vkCreateImageView(device, &imageViewCI, nullptr, &m_DirImageView);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreateLowPassResources(VkDevice device)
    {
        // Create sampler
        VkSamplerCreateInfo samplerCI;
        samplerCI.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
        samplerCI.pNext = nullptr;
        samplerCI.flags = 0;
        samplerCI.magFilter = VK_FILTER_LINEAR;
        samplerCI.minFilter = VK_FILTER_LINEAR;
        samplerCI.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
        samplerCI.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
        samplerCI.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
        samplerCI.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
        samplerCI.mipLodBias = 0.0f;
        samplerCI.anisotropyEnable = VK_FALSE;
        samplerCI.maxAnisotropy = 0.0f;
        samplerCI.compareEnable = VK_FALSE;
        samplerCI.compareOp = VK_COMPARE_OP_LESS;
        samplerCI.minLod = 0.0f;
        samplerCI.maxLod = 0.0f;
        samplerCI.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
        samplerCI.unnormalizedCoordinates = VK_FALSE;

        VkResult result = vkCreateSampler(device, &samplerCI, nullptr, &m_LowPassSampler);
        ASSERT_VULKAN(result);

        // Allocate descriptor set
        VkDescriptorSetAllocateInfo descAI;
        descAI.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
        descAI.pNext = nullptr;
        descAI.descriptorPool = m_DescriptorPool;
        descAI.descriptorSetCount = 1;
        descAI.pSetLayouts = &m_DescriptorSetLayout;

        result = vkAllocateDescriptorSets(device, &descAI, &m_DescriptorSet);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::CreateLowPassImage(VkDevice device)
    {
        // Create Image
        VkImageCreateInfo imageCI;
        imageCI.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        imageCI.pNext = nullptr;
        imageCI.flags = 0;
        imageCI.imageType = VK_IMAGE_TYPE_2D;
        imageCI.format = VulkanAPI::GetSurfaceFormat().format;
        imageCI.extent = { m_FrameWidth, m_FrameHeight, 1 };
        imageCI.mipLevels = 1;
        imageCI.arrayLayers = 1;
        imageCI.samples = VK_SAMPLE_COUNT_1_BIT;
        imageCI.tiling = VK_IMAGE_TILING_OPTIMAL;
        imageCI.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
        imageCI.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        imageCI.queueFamilyIndexCount = 0;
        imageCI.pQueueFamilyIndices = nullptr;
        imageCI.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

        VkResult result = vkCreateImage(device, &imageCI, nullptr, &m_LowPassImage);
        ASSERT_VULKAN(result);

        // Image Memory
        VkMemoryRequirements memoryRequirements;
        vkGetImageMemoryRequirements(device, m_LowPassImage, &memoryRequirements);

        VkMemoryAllocateInfo allocateInfo;
        allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        allocateInfo.pNext = nullptr;
        allocateInfo.allocationSize = memoryRequirements.size;
        allocateInfo.memoryTypeIndex = VulkanAPI::FindMemoryType(
                memoryRequirements.memoryTypeBits,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

        result = vkAllocateMemory(device, &allocateInfo, nullptr, &m_LowPassImageMemory);
        ASSERT_VULKAN(result);

        result = vkBindImageMemory(device, m_LowPassImage, m_LowPassImageMemory, 0);
        ASSERT_VULKAN(result);

        // Create image view
        VkImageViewCreateInfo imageViewCI;
        imageViewCI.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        imageViewCI.pNext = nullptr;
        imageViewCI.flags = 0;
        imageViewCI.image = m_LowPassImage;
        imageViewCI.viewType = VK_IMAGE_VIEW_TYPE_2D;
        imageViewCI.format = VulkanAPI::GetSurfaceFormat().format;
        imageViewCI.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
        imageViewCI.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageViewCI.subresourceRange.baseMipLevel = 0;
        imageViewCI.subresourceRange.levelCount = 1;
        imageViewCI.subresourceRange.baseArrayLayer = 0;
        imageViewCI.subresourceRange.layerCount = 1;

        result = vkCreateImageView(device, &imageViewCI, nullptr, &m_LowPassImageView);
        ASSERT_VULKAN(result);

        // Update descriptor set
        VkDescriptorImageInfo lowPassImageInfo;
        lowPassImageInfo.sampler = m_LowPassSampler;
        lowPassImageInfo.imageView = m_LowPassImageView;
        lowPassImageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;

        VkWriteDescriptorSet lowPassImageWrite;
        lowPassImageWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        lowPassImageWrite.pNext = nullptr;
        lowPassImageWrite.dstSet = m_DescriptorSet;
        lowPassImageWrite.dstBinding = 0;
        lowPassImageWrite.dstArrayElement = 0;
        lowPassImageWrite.descriptorCount = 1;
        lowPassImageWrite.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        lowPassImageWrite.pImageInfo = &lowPassImageInfo;
        lowPassImageWrite.pBufferInfo = nullptr;
        lowPassImageWrite.pTexelBufferView = nullptr;

        vkUpdateDescriptorSets(device, 1, &lowPassImageWrite, 0, nullptr);

        // Change image layout to general
        vk::CommandPool commandPool(0, VulkanAPI::GetGraphicsQFI());
        commandPool.AllocateBuffers(1, VK_COMMAND_BUFFER_LEVEL_PRIMARY);
        VkCommandBuffer commandBuffer = commandPool.GetBuffer(0);

        VkCommandBufferBeginInfo beginInfo;
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.pNext = nullptr;
        beginInfo.flags = 0;
        beginInfo.pInheritanceInfo = nullptr;

        result = vkBeginCommandBuffer(commandBuffer, &beginInfo);
        ASSERT_VULKAN(result);

        vk::CommandRecorder::ImageLayoutTransfer(
                commandBuffer,
                m_LowPassImage,
                VK_IMAGE_LAYOUT_UNDEFINED,
                VK_IMAGE_LAYOUT_GENERAL,
                VK_ACCESS_NONE,
                VK_ACCESS_TRANSFER_WRITE_BIT,
                VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
                VK_PIPELINE_STAGE_TRANSFER_BIT);

        result = vkEndCommandBuffer(commandBuffer);
        ASSERT_VULKAN(result);

        VkSubmitInfo submitInfo;
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.pNext = nullptr;
        submitInfo.waitSemaphoreCount = 0;
        submitInfo.pWaitSemaphores = nullptr;
        submitInfo.pWaitDstStageMask = nullptr;
        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &commandBuffer;
        submitInfo.signalSemaphoreCount = 0;
        submitInfo.pSignalSemaphores = nullptr;

        VkQueue queue = VulkanAPI::GetGraphicsQueue();

        result = vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
        ASSERT_VULKAN(result);

        result = vkQueueWaitIdle(queue);
        ASSERT_VULKAN(result);

        commandPool.Destroy();
    }

    void NrcHpmRenderer::CreateFramebuffer(VkDevice device)
    {
        std::vector<VkImageView> attachments = { m_ColorImageView, m_PosImageView, m_DirImageView };

        VkFramebufferCreateInfo createInfo;
        createInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        createInfo.pNext = nullptr;
        createInfo.flags = 0;
        createInfo.renderPass = m_RenderPass;
        createInfo.attachmentCount = attachments.size();
        createInfo.pAttachments = attachments.data();
        createInfo.width = m_FrameWidth;
        createInfo.height = m_FrameHeight;
        createInfo.layers = 1;

        VkResult result = vkCreateFramebuffer(device, &createInfo, nullptr, &m_Framebuffer);
        ASSERT_VULKAN(result);
    }

    void NrcHpmRenderer::RecordCommandBuffer()
    {
        VkCommandBufferBeginInfo beginInfo;
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.pNext = nullptr;
        beginInfo.flags = 0;
        beginInfo.pInheritanceInfo = nullptr;

        VkResult result = vkBeginCommandBuffer(m_CommandBuffer, &beginInfo);
        if (result != VK_SUCCESS)
            Log::Error("Failed to begin VkCommandBuffer", true);

        std::vector<VkClearValue> clearValues = {
                { 0.0f, 0.0f, 0.0f, 1.0f },
                { 0.0f, 0.0f, 0.0f, 1.0f },
                { 0.0f, 0.0f, 0.0f, 1.0f } };

        VkRenderPassBeginInfo renderPassBeginInfo;
        renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        renderPassBeginInfo.pNext = nullptr;
        renderPassBeginInfo.renderPass = m_RenderPass;
        renderPassBeginInfo.framebuffer = m_Framebuffer;
        renderPassBeginInfo.renderArea.offset = { 0, 0 };
        renderPassBeginInfo.renderArea.extent = { m_FrameWidth, m_FrameHeight };
        renderPassBeginInfo.clearValueCount = clearValues.size();
        renderPassBeginInfo.pClearValues = clearValues.data();
        vkCmdBeginRenderPass(m_CommandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

        vkCmdBindPipeline(m_CommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_Pipeline);

        // Viewport
        VkViewport viewport;
        viewport.x = 0.0f;
        viewport.y = 0.0f;
        viewport.width = static_cast<float>(m_FrameWidth);
        viewport.height = static_cast<float>(m_FrameHeight);
        viewport.minDepth = 0.0f;
        viewport.maxDepth = 1.0f;

        vkCmdSetViewport(m_CommandBuffer, 0, 1, &viewport);

        // Scissor
        VkRect2D scissor;
        scissor.offset = { 0, 0 };
        scissor.extent = { m_FrameWidth, m_FrameHeight };

        vkCmdSetScissor(m_CommandBuffer, 0, 1, &scissor);

        // Bind descriptor sets
        std::vector<VkDescriptorSet> descSets = {
                m_Camera.GetDescriptorSet(),
                m_VolumeData.GetDescriptorSet(),
                m_DirLight.GetDescriptorSet(),
                m_DescriptorSet };

        vkCmdBindDescriptorSets(
                m_CommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_PipelineLayout,
                0, descSets.size(), descSets.data(),
                0, nullptr);

        // Draw
        vkCmdDraw(m_CommandBuffer, 6, 1, 0, 0);

        // End render pass
        vkCmdEndRenderPass(m_CommandBuffer);

        // Copy result to low pass image
        VkImageCopy imageCopy;
        imageCopy.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageCopy.srcSubresource.mipLevel = 0;
        imageCopy.srcSubresource.baseArrayLayer = 0;
        imageCopy.srcSubresource.layerCount = 1;
        imageCopy.srcOffset = { 0, 0, 0 };
        imageCopy.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        imageCopy.dstSubresource.mipLevel = 0;
        imageCopy.dstSubresource.baseArrayLayer = 0;
        imageCopy.dstSubresource.layerCount = 1;
        imageCopy.dstOffset = { 0, 0, 0 };
        imageCopy.extent = { m_FrameWidth, m_FrameHeight, 1 };

        vkCmdCopyImage(
                m_CommandBuffer,
                m_ColorImage,
                VK_IMAGE_LAYOUT_GENERAL,
                m_LowPassImage,
                VK_IMAGE_LAYOUT_GENERAL,
                1,
                &imageCopy);

        // End
        result = vkEndCommandBuffer(m_CommandBuffer);
        if (result != VK_SUCCESS)
            Log::Error("Failed to end VkCommandBuffer", true);
    }
}