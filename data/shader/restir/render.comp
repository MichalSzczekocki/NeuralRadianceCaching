#version 460
#define RESTIR
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

vec4 ShadePath(const ivec2 imageCoord)
{
    const vec4 restirStats = imageLoad(restirStatsImage, imageCoord);
    const uint exchangeStartVertex = uint(restirStats.y);

    vec3 scatteredLight = vec3(0.0);
    float transmittance = 1.0;

    vec3 vertexPos;
    vec3 vertexDir;
    LoadPathVertex(imageCoord, 0, vertexPos, vertexDir);

    vec3 currentPoint;
    vec3 lastPoint = vertexPos;

    vec3 currentDir;
    vec3 lastDir = vec3(0.0);

    float totalPhaseFactor = 1.0;

    for (uint i = 1; i < PATH_VERTEX_COUNT; i++)
    {
        LoadPathVertex(imageCoord, i, vertexPos, vertexDir);

        currentPoint = vertexPos;
        currentDir = normalize(currentPoint - lastPoint);

        const float density = getDensity(currentPoint);

        if (density > 0.0)
        {
            // Get scene lighting
            const vec3 sceneLighting = TraceScene(currentPoint, currentDir, vertexDir);

            // Phase factor
            const float phase = i == exchangeStartVertex ? hg_phase_func(dot(lastDir, -currentDir)) : 1.0; // Importance sampling
            totalPhaseFactor *= phase;

            // Transmittance calculation
            const vec3 s_int = density * sceneLighting * totalPhaseFactor;
            const float t_r = GetTransmittance(currentPoint, lastPoint, 8);

            scatteredLight += transmittance * s_int;
            transmittance *= t_r;

            // Update last
            lastPoint = currentPoint;
            lastDir = currentDir;
        }
    }

    return vec4(scatteredLight, transmittance);
}

vec4 TracePath(const ivec2 imageCoord)
{
    const vec4 pathOutput = ShadePath(imageCoord);
    return pathOutput;
}

void main()
{
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const ivec2 imageCoord = ivec2(x, y);

    // Fraguv and world pos
    const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);

    // Setup random
    preRand = volumeData.random.x * fragUV.x;
    prePreRand = volumeData.random.y * fragUV.y;

    // Load pixel info
    const vec4 pixelInfo = imageLoad(pixelInfoImage, imageCoord);
    const vec3 backgroundColor = pixelInfo.xyz;
    const bool didScatter = pixelInfo.w == 1.0;

    // Shading
    vec4 primaryRayColor;
    if (didScatter)
    {
        primaryRayColor = TracePath(imageCoord);
    }
    else
    {
        primaryRayColor = vec4(vec3(0.0), 1.0);
    }

    if (primaryRayColor.w == 1.0)
    {
        primaryRayColor.xyz = backgroundColor;
    }

    const ivec2 invertedYImageCoord = ivec2(x, RENDER_HEIGHT - (y + 1));
    imageStore(outputImage, invertedYImageCoord, primaryRayColor);
}
