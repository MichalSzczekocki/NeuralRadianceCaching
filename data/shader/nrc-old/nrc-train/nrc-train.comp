#version 460

#include "common.glsl"

void EncodeRay(vec3 pos, const vec3 dir)
{
	EncodePosMrhe(pos);
	EncodeDirOneBlob(dir);

	for (uint i = 0; i < 32; i++)
	{
		nr0[i] = mrheFeatures[i];
		nr0[i + 32] = oneBlobFeatures[i];
	}
}

void Backprop(vec3 target, const vec3 pos, const vec3 dir)
{
	target = min(target, vec3(1024.0));
	//target = vec3(10.0, 0.0, 0.0);

	// Forward
	EncodeRay(pos, dir);

	for (uint i = 0; i < 5; i++)
	{
		if (isnan(nr0[i]))
		{
			return;
		}
	}

	Forward();
	const vec3 pred = vec3(nr6[0], nr6[1], nr6[2]);
	//debugPrintfEXT("%f, %f, %f\n", nr6[0], nr6[1], nr6[2]);

	// Backprop
	const vec3 error = pred - target;
	const float mseLoss = ((error.x * error.x) + (error.y * error.y) + (error.z * error.z)) / 3.0;
	atomicAdd(nrcStats.mseLoss, mseLoss * ONE_OVER_PIXEL_COUNT);

	nr6[0] = 2.0 * error.x;
	nr6[1] = 2.0 * error.y;
	nr6[2] = 2.0 * error.z;

	//nr6[0] = sign(error.x);
	//nr6[1] = sign(error.y);
	//nr6[2] = sign(error.z);

	//debugPrintfEXT("%f, %f, %f\n", nr6[0], nr6[1], nr6[2]);
	//debugPrintfEXT("%f, %f, %f\n", target.x, target.y, target.z);

	Backprop5();
	Backprop4();
	Backprop3();
	Backprop2();
	Backprop1();
	Backprop0();
	BackpropMrhe();
}

// End: NN

#define TRUE_TRACE_SAMPLE_COUNT 32
vec3 TracePath(const vec3 rayOrigin, const vec3 rayDir)
{
	vec3 scatteredLight = vec3(0.0);
	float transmittance = 1.0;

	const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];

	vec3 currentPoint = entry;
	vec3 lastPoint = entry;

	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	for (uint i = 0; i < TRUE_TRACE_SAMPLE_COUNT; i++)
	{
		const float density = getDensity(currentPoint);

		if (density > 0.0)
		{
			// Get scene lighting
			const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

			// Phase factor
			const float phase = 1.0; // Importance sampling

			// Transmittance calculation
			const vec3 s_int = density * sceneLighting;
			const float t_r = GetTransmittance(currentPoint, lastPoint, 32);

			scatteredLight += transmittance * s_int;
			transmittance *= t_r;

			// Update last
			lastPoint = currentPoint;
			lastDir = currentDir;

			// Generate new direction
			currentDir = NewRayDir(currentDir);
		}

		// Generate new point
		const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		const float maxDistance = distance(exit, currentPoint) * 0.1;
		const float nextDistance = RandFloat(maxDistance);
		currentPoint = currentPoint + (currentDir * nextDistance);
	}

	return scatteredLight;
}

void TracePathAndLearn(const vec3 rayOrigin, const vec3 rayDir)
{
	const vec3[2] entryExit = find_entry_exit(rayOrigin, rayDir);
	const vec3 entry = entryExit[0];
	const vec3 exit = entryExit[1];

	vec3 currentPoint = entry;
	vec3 lastPoint = entry;

	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	float totalTermProb = 1.0;

	bool didScatter = false;

	// Trace path and terminate at random
	for (uint i = 0; i < TRUE_TRACE_SAMPLE_COUNT; i++)
	{
		if (RandFloat(1.0) > totalTermProb)
		{
			break;
		}
		totalTermProb *= 0.5;

		// Generate new ray
		if (getDensity(currentPoint) > 0.0)
		{
			didScatter = true;
			currentDir = NewRayDir(currentDir);
		}

		const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		const float maxDistance = distance(exit, currentPoint) * 0.1;
		const float nextDistance = maxDistance * RandFloat(1.0);
		currentPoint = currentPoint + (currentDir * nextDistance);
	}

	if (!didScatter)
	{
		currentPoint = entry;
		currentDir = -normalize(currentPoint);
	}

	const uint sampleCount = 4;
	vec3 tracedLight = vec3(0.0);
	for (uint i = 0; i < sampleCount; i++)
	{
		tracedLight += TracePath(currentPoint, currentDir);
	}
	tracedLight /= float(sampleCount);

	Backprop(tracedLight, currentPoint, currentDir);
}

void main()
{
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;

	// Fraguv and world pos
	const vec2 fragUV = vec2(float(x) * WIDTH_FACTOR, float(y) * HEIGHT_FACTOR);
	const vec4 screenCoord = vec4((fragUV * 2.0) - vec2(1.0), 0.0, 1.0);
	const vec4 worldPos = camMat.invProjView * screenCoord;
	const vec3 pixelWorldPos = worldPos.xyz / worldPos.w;

	// Setup random
	preRand = volumeData.random.x * fragUV.x;
	prePreRand = volumeData.random.y * fragUV.y;

	// Setup ray
	const vec3 ro = camera.pos;
	vec3 rd = normalize(pixelWorldPos - ro);

	// SDF
	const vec3[2] entry_exit = find_entry_exit(ro, rd);
	const vec3 entry = entry_exit[0];
	const vec3 exit = entry_exit[1];

	if (sky_sdf(entry) > MAX_RAY_DISTANCE)
	{
		rd = -normalize(ro);
	}

	// Learn
	TracePathAndLearn(ro, rd);
}
