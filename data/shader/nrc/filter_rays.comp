#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void LoadNeuralRayFromImages(const ivec2 imageCoord, out vec3 rayOrigin, out vec3 rayDir)
{
    rayOrigin = imageLoad(nrcNeuralRayOriginImage, imageCoord).xyz;
    rayDir = imageLoad(nrcNeuralRayDirImage, imageCoord).xyz;
}

void EncodeRay(const uint globalSampleIndex, const vec3 rayOrigin, const vec3 rayDir)
{
    const uint startIndex = globalSampleIndex * INPUT_FEATURE_COUNT;

    // Norm ray origin
    const vec3 normRayOrigin = (rayOrigin / skySize) + vec3(0.5);

    // Dir to phi theta
    const float phi = atan(rayDir.x, rayDir.z);
    const float theta = atan(length(rayDir.xz), rayDir.y);

    // Encode pos
    // Always encode direct
    const uint directPosIndex = startIndex;
    renderNeurons[directPosIndex + 0] = float16_t(normRayOrigin.x);
    renderNeurons[directPosIndex + 1] = float16_t(normRayOrigin.y);
    renderNeurons[directPosIndex + 2] = float16_t(normRayOrigin.z);

    // Encode pos frequency
    const uint freqPosIndex = directPosIndex + 3;
    if (POS_ENCODING == 1 || POS_ENCODING == 2)
    {
        for (uint freq = 0; freq < POS_FREQ_COUNT; freq++)
        {
            const float waveScale = pow(2.0, float(freq)) * PI;
            renderNeurons[freqPosIndex + (freq * 6) + 0] = float16_t(sin(waveScale * normRayOrigin.x));
            renderNeurons[freqPosIndex + (freq * 6) + 1] = float16_t(cos(waveScale * normRayOrigin.x));
            renderNeurons[freqPosIndex + (freq * 6) + 2] = float16_t(sin(waveScale * normRayOrigin.y));
            renderNeurons[freqPosIndex + (freq * 6) + 3] = float16_t(cos(waveScale * normRayOrigin.y));
            renderNeurons[freqPosIndex + (freq * 6) + 4] = float16_t(sin(waveScale * normRayOrigin.z));
            renderNeurons[freqPosIndex + (freq * 6) + 5] = float16_t(cos(waveScale * normRayOrigin.z));
        }
    }

    // Encode pos mrhe
    const uint mrhePosIndex = freqPosIndex + (POS_FREQ_COUNT * 6);
    if (POS_ENCODING == 2)
    {
        EncodePosMrhe(normRayOrigin, mrhePosIndex);
    }

    // Encode dir
    uint directDirIndex = directPosIndex + 3;
    if (POS_ENCODING == 1)
    {
        directDirIndex += POS_FREQ_COUNT * 6;
    }
    else if (POS_ENCODING == 2)
    {
        directDirIndex += (POS_FREQ_COUNT * 6) + (POS_LEVEL_COUNT * POS_FEATURE_COUNT);
    }

    // Encode dir direct
    renderNeurons[directDirIndex + 0] = float16_t(phi);
    renderNeurons[directDirIndex + 1] = float16_t(theta);

    // Encode dir freq
    const uint freqDirIndex = directDirIndex + 2;
    if (DIR_ENCODING == 1 || DIR_ENCODING == 2)
    {
        for (uint freq = 0; freq < DIR_FREQ_COUNT; freq++)
        {
            const float waveScale = pow(2.0, float(freq)); // No PI because PI is in phi and theta
            renderNeurons[freqDirIndex + (freq * 4) + 0] = float16_t(sin(waveScale * phi));
            renderNeurons[freqDirIndex + (freq * 4) + 1] = float16_t(cos(waveScale * phi));
            renderNeurons[freqDirIndex + (freq * 4) + 2] = float16_t(sin(waveScale * theta));
            renderNeurons[freqDirIndex + (freq * 4) + 3] = float16_t(cos(waveScale * theta));
        }
    }

    // Encode dir one blob
    const uint oneBlobDirIndex = freqDirIndex + (DIR_FREQ_COUNT * 4);
    if (DIR_ENCODING == 2)
    {
        const float normPhi = (phi / (2.0 * PI)) + 0.5;
        const float normTheta = (theta / PI) + 0.5;

        for (uint feature = 0; feature < DIR_FEATURE_COUNT; feature++)
        {
            const float angleSample = float(feature) / float(DIR_FEATURE_COUNT);
            renderNeurons[oneBlobDirIndex + (feature * 2) + 0] = float16_t(NormGauss(angleSample, normPhi, ONE_OVER_DIR_FEATURE_COUNT));
            renderNeurons[oneBlobDirIndex + (feature * 2) + 1] = float16_t(NormGauss(angleSample, normTheta, ONE_OVER_DIR_FEATURE_COUNT));
        }
    }
}

void CopyToTrainInputs(const uint globalSampleIndex, const uint trainSampleIndex)
{
    for (uint inputFeature = 0; inputFeature < INPUT_FEATURE_COUNT; inputFeature++)
    {
        trainNeurons[(trainSampleIndex * INPUT_FEATURE_COUNT) + inputFeature] =
        renderNeurons[(globalSampleIndex * INPUT_FEATURE_COUNT) + inputFeature];
    }
}

#define PATH_SAMPLE_COUNT 32
vec4 TracePath(const vec3 rayOrigin, const vec3 rayDir)
{
    vec3 scatteredLight = vec3(0.0);
    float transmittance = 1.0;

    const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];

    vec3 currentPoint = entry;
    vec3 lastPoint = entry;

    vec3 currentDir = rayDir;
    vec3 lastDir = vec3(0.0);

    for (uint i = 0; i < PATH_SAMPLE_COUNT; i++)
    {
        const float density = getDensity(currentPoint);

        if (density > 0.0)
        {
            // Get scene lighting
            const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

            // Phase factor
            const float phase = 1.0; // Importance sampling

            // Transmittance calculation
            const vec3 s_int = density * sceneLighting * phase;
            const float t_r = GetTransmittance(currentPoint, lastPoint, 32);

            scatteredLight += transmittance * s_int;
            transmittance *= t_r;

            // Update last
            lastPoint = currentPoint;
            lastDir = currentDir;

            // Generate new direction
            currentDir = NewRayDir(currentDir, true);
        }

        // Generate new point
        const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
        const float maxDistance = distance(exit, currentPoint) * 0.1;
        const float nextDistance = RandFloat(maxDistance);
        currentPoint = currentPoint + (currentDir * nextDistance);
    }

    return vec4(scatteredLight, transmittance);
}

void CalcTrainTarget(const ivec2 trainImageCoord, const vec3 rayOrigin, const vec3 rayDir)
{
    vec3 target = vec3(1.0, 0.0, 1.0);//TracePath(rayOrigin, rayDir).xyz;
    imageStore(nrcNeuralRayTargetImage, trainImageCoord, vec4(target, 0.0));
}

void main()
{
    const ivec2 imageCoord = ivec2(gl_GlobalInvocationID.xy);
    const uint linearPixelIndex = (imageCoord.y * RENDER_WIDTH) + imageCoord.x;

    vec3 rayOrigin;
    vec3 rayDir;
    LoadNeuralRayFromImages(imageCoord, rayOrigin, rayDir);
    EncodeRay(linearPixelIndex, rayOrigin, rayDir);

    if (imageCoord.x % RENDER_OVER_TRAIN_WIDTH == 0 && imageCoord.y % RENDER_OVER_TRAIN_HEIGHT == 0)
    {
        const ivec2 trainImageCoord = imageCoord / ivec2(RENDER_OVER_TRAIN_WIDTH, RENDER_OVER_TRAIN_HEIGHT);
        const uint trainSampleIndex = (trainImageCoord.y * TRAIN_WIDTH) + trainImageCoord.x;
        CopyToTrainInputs(linearPixelIndex, trainSampleIndex);
        CalcTrainTarget(trainImageCoord, rayOrigin, rayDir);
    }
}
