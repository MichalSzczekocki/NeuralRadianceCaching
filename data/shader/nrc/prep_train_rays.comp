#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void StoreNrcTrainData(const ivec2 trainImageCoord, const vec3 pos, const vec3 dir, vec3 target)
{
    // Calc index
    const uint x = trainImageCoord.x;
    const uint y = trainImageCoord.y;
    const uint linearPixelIndex = (y * TRAIN_WIDTH) + x;

    // Norm pos
    const vec3 normPos = (pos / skySize) + (skySize / 2.0);

    // Calc dir
    const float theta = atan(dir.z, dir.x);
    const float normTheta = (theta / PI) + 0.5;
    const float phi = acos(dir.y / length(dir.xz));
    const float normPhi = phi / PI;

    // Store train input
    nrcTrainInput[linearPixelIndex].posX = normPos.x;
    nrcTrainInput[linearPixelIndex].posY = normPos.y;
    nrcTrainInput[linearPixelIndex].posZ = normPos.z;
    nrcTrainInput[linearPixelIndex].theta = normTheta;
    nrcTrainInput[linearPixelIndex].phi = normPhi;

    // Store train target
    target = log(vec3(1.0) + target);
    target = min(vec3(16.0), target);

    nrcTrainTarget[linearPixelIndex].r = target.x;
    nrcTrainTarget[linearPixelIndex].g = target.y;
    nrcTrainTarget[linearPixelIndex].b = target.z;

    // Store randomly in reservoir
    const uint resRayX = uint(RandFloat(float(TRAIN_WIDTH)));
    const uint resRayY = uint(RandFloat(float(TRAIN_HEIGHT)));
    const uint linearResIndex = (resRayY * TRAIN_WIDTH) + resRayX;

    atomicExchange(nrcTrainRayRes[linearResIndex].posX, pos.x);
    atomicExchange(nrcTrainRayRes[linearResIndex].posY, pos.y);
    atomicExchange(nrcTrainRayRes[linearResIndex].posZ, pos.z);

    atomicExchange(nrcTrainRayRes[linearResIndex].dirX, dir.x);
    atomicExchange(nrcTrainRayRes[linearResIndex].dirY, dir.y);
    atomicExchange(nrcTrainRayRes[linearResIndex].dirZ, dir.z);
}

#define PATH_SAMPLE_COUNT 32
vec4 TracePath(const vec3 rayOrigin, const vec3 rayDir)
{
    vec3 scatteredLight = vec3(0.0);
    float transmittance = 1.0;

    const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];

    vec3 currentPoint = entry;
    vec3 lastPoint = entry;

    vec3 currentDir = rayDir;
    vec3 lastDir = vec3(0.0);

    bool volumeExit = false;
    for (uint i = 0; i < PATH_SAMPLE_COUNT; i++)
    {
        const float density = getDensity(currentPoint);

        if (density > 0.0)
        {
            // Get scene lighting
            const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

            // Phase factor
            const float phase = 1.0; // Importance sampling

            // Transmittance calculation
            const vec3 s_int = density * sceneLighting * phase;
            const float t_r = RatioTrack(lastPoint, currentPoint);

            scatteredLight += transmittance * s_int;
            transmittance *= t_r;

            // Update last
            lastPoint = currentPoint;
            lastDir = currentDir;

            // Generate new direction
            currentDir = NewRayDir(currentDir, true);
        }

        // Generate new point
        currentPoint = DeltaTrack(currentPoint, currentDir, volumeExit);
    }

    return vec4(scatteredLight, transmittance);
}

void main()
{
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const ivec2 trainImageCoord = ivec2(x, y);
    const ivec2 renderImageCoord = trainImageCoord * ivec2(RENDER_OVER_TRAIN_WIDTH, RENDER_OVER_TRAIN_HEIGHT);
    const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);

    // Setup random
    InitRandom(fragUV);

    const vec3 rayOrigin = imageLoad(nrcRayOriginImage, renderImageCoord).xyz;
    const vec3 rayDir = imageLoad(nrcRayDirImage, renderImageCoord).xyz;

    vec3 target = vec3(0.0);
    for (uint i = 0; i < TRAIN_SPP; i++)
    {
        target += TracePath(rayOrigin, rayDir).xyz;
    }
    target /= float(TRAIN_SPP);

    StoreNrcTrainData(trainImageCoord, rayOrigin, rayDir, target);
}
