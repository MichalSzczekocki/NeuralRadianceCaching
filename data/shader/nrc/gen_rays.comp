#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#define PATH_SAMPLE_COUNT 32
vec4 TracePath(const ivec2 imageCoord, const vec3 rayOrigin, const vec3 rayDir, out bool didScatter)
{
    vec3 scatteredLight = vec3(0.0);
    float transmittance = 1.0;

    const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];

    vec3 currentPoint = entry;
    vec3 lastPoint = entry;

    vec3 currentDir = rayDir;
    vec3 lastDir = vec3(0.0);

    float totalTermProb = 1.0;

    didScatter = false;
    bool volumeExit = false;
    for (uint i = 0; i < PATH_SAMPLE_COUNT; i++)
    {
        const float density = getDensity(currentPoint);

        if (density > 0.0)
        {
            didScatter = true;

            if (RandFloat(1.0) > totalTermProb)
            {
                // Store nrc ray info
                imageStore(nrcRayOriginImage, imageCoord, vec4(currentPoint, 0.0));
                imageStore(nrcRayDirImage, imageCoord, vec4(currentDir, 0.0));

                // Return prematurly terminated ray color
                return vec4(scatteredLight, transmittance);
            }
            totalTermProb *= 0.5;

            // Get scene lighting
            const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

            // Phase factor
            const float phase = 1.0; // Importance sampling

            // Transmittance calculation
            const vec3 s_int = density * sceneLighting * phase;
            //const float t_r = GetTransmittance(currentPoint, lastPoint, 32);
            const float t_r = RatioTrack(lastPoint, currentPoint);

            scatteredLight += transmittance * s_int;
            transmittance *= t_r;

            // Update last
            lastPoint = currentPoint;
            lastDir = currentDir;

            // Generate new direction
            currentDir = NewRayDir(currentDir, true);
        }

        // Generate new point
        currentPoint = DeltaTrack(currentPoint, currentDir, volumeExit);
    }

    return vec4(scatteredLight, transmittance);
}

void main()
{
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    ivec2 imageCoord = ivec2(x, y);

    // Fraguv and world pos
    const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);
    const vec4 screenCoord = vec4((fragUV * 2.0) - vec2(1.0), 0.0, 1.0);
    const vec4 worldPos = camMat.invProjView * screenCoord;
    const vec3 pixelWorldPos = worldPos.xyz / worldPos.w;

    // Setup random
    preRand = volumeData.random.x * fragUV.x;
    prePreRand = volumeData.random.y * fragUV.y;

    // Setup ray
    const vec3 ro = camera.pos;
    vec3 rd = normalize(pixelWorldPos - ro);

    // SDF + render
    const vec3[2] entry_exit = find_entry_exit(ro, rd);
    const vec3 entry = entry_exit[0];
    const vec3 exit = entry_exit[1];

    vec4 primaryRayColor;
    vec4 primaryRayInfo;
    bool didScatter = false;
    if (sky_sdf(entry) > MAX_RAY_DISTANCE)
    {
        primaryRayColor = vec4(SampleHdrEnvMap(rd, false), 1.0);
        primaryRayInfo = vec4(0.0);
    }
    else
    {
        primaryRayColor = TracePath(imageCoord, ro, rd, didScatter);
        if (!didScatter)
        {
            primaryRayColor = vec4(SampleHdrEnvMap(rd, false), 1.0);
        }
    }

    primaryRayInfo = vec4(didScatter ? 1.0 : 0.0, 0.0, 0.0, 0.0);

    // Store output
    imageStore(primaryRayColorImage, imageCoord, primaryRayColor);
    imageStore(primaryRayInfoImage, imageCoord, primaryRayInfo);
}
