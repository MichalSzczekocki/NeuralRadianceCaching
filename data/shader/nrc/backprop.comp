#version 460
#include "common.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

const uint samplesPerThread = BATCH_SIZE / gl_WorkGroupSize.x;

float ReLUDeriv(const float x)
{
    return x > 0.0 ? 1.0 : 0.0;
}

void Backprop(
const uint globalSampleIndex,
const uint inputNeuronOffset,
const uint weightsOffset,
const uint biasesOffset,
const uint outputNeuronOffset,
const uint inputLayerWidth,
const uint outputLayerWidth)
{
    // Backprop through activation
    for (uint outputNeuron = 0; outputNeuron < outputLayerWidth; outputNeuron++)
    {
        const uint neuronIndex = outputNeuronOffset + (globalSampleIndex * outputLayerWidth) + outputNeuron;
        const float activatedValue = trainNeurons[neuronIndex];
        trainNeurons[neuronIndex] *= ReLUDeriv(activatedValue);
    }

    // Calc delta weights and biases
    for (uint row = 0; row < outputLayerWidth; row++)
    {
        const float outputVal = trainNeurons[outputNeuronOffset + (globalSampleIndex * outputLayerWidth) + row];

        // Delta weights
        for (uint col = 0; col < inputLayerWidth; col++)
        {
            const float inputVal = trainNeurons[inputNeuronOffset + (globalSampleIndex * inputLayerWidth) + col];
            const float delta = -inputVal * outputVal;

            const uint weightIndex = weightsOffset + (col * outputLayerWidth) + row;
            atomicAdd(deltaWeights[weightIndex], delta);
        }

        // Delta biases
        atomicAdd(deltaBiases[biasesOffset + row], -outputVal);
    }

    // Backprop through weights
    for (uint col = 0; col < inputLayerWidth; col++)
    {
        float sum = 0.0;
        for (uint row = 0; row < outputLayerWidth; row++)
        {
            const float outputVal = trainNeurons[outputNeuronOffset + (globalSampleIndex * outputLayerWidth) + row];
            const float weightVal = weights[weightsOffset + (col * outputLayerWidth) + row];
            sum += weightVal * outputVal;
        }
        trainNeurons[inputNeuronOffset + (globalSampleIndex * inputLayerWidth) + col] = sum;
    }
}

void BackpropOutputLayer(const uint globalSampleIndex)
{
    const uint inputNeuronOffset = TRAIN_SAMPLE_COUNT * (INPUT_FEATURE_COUNT + (LAYER_WIDTH * (LAYER_COUNT - 1)));
    const uint weightsOffset =  (INPUT_FEATURE_COUNT * LAYER_WIDTH) + (LAYER_WIDTH * LAYER_WIDTH * LAYER_COUNT);
    const uint biasesOffset = LAYER_WIDTH * LAYER_COUNT;
    const uint outputNeuronOffset = TRAIN_OUTPUT_NEURONS_INDEX;//inputNeuronOffset + (TRAIN_SAMPLE_COUNT * LAYER_WIDTH);
    const uint inputLayerWidth = LAYER_WIDTH;
    const uint outputLayerWidth = 3;

    Backprop(
        globalSampleIndex,
        inputNeuronOffset,
        weightsOffset,
        biasesOffset,
        outputNeuronOffset,
        inputLayerWidth,
        outputLayerWidth);
}

void BackpropHiddenLayer(const uint globalSampleIndex, const uint hiddenLayerIndex)
{
    const uint inputNeuronOffset = TRAIN_SAMPLE_COUNT * (INPUT_FEATURE_COUNT + (LAYER_WIDTH * hiddenLayerIndex));
    const uint weightsOffset = (INPUT_FEATURE_COUNT * LAYER_WIDTH) + (LAYER_WIDTH * LAYER_WIDTH * hiddenLayerIndex);
    const uint biasesOffset = LAYER_WIDTH * (hiddenLayerIndex + 1);
    const uint outputNeuronOffset = inputNeuronOffset + (TRAIN_SAMPLE_COUNT * LAYER_WIDTH);
    const uint inputLayerWidth = LAYER_WIDTH;
    const uint outputLayerWidth = LAYER_WIDTH;

    Backprop(
        globalSampleIndex,
        inputNeuronOffset,
        weightsOffset,
        biasesOffset,
        outputNeuronOffset,
        inputLayerWidth,
        outputLayerWidth);
}

void BackpropInputLayer(const uint globalSampleIndex)
{
    const uint inputNeuronOffset = 0;
    const uint weightsOffset = 0;
    const uint biasesOffset = 0;
    const uint outputNeuronOffset = INPUT_FEATURE_COUNT * TRAIN_SAMPLE_COUNT;
    const uint inputLayerWidth = INPUT_FEATURE_COUNT;
    const uint outputLayerWidth = LAYER_WIDTH;

    Backprop(
        globalSampleIndex,
        inputNeuronOffset,
        weightsOffset,
        biasesOffset,
        outputNeuronOffset,
        inputLayerWidth,
        outputLayerWidth);
}

void Backprop(const uint batchIndex, const uint sampleIndex)
{
    const uint globalSampleIndex = (batchIndex * BATCH_SIZE) + sampleIndex;

    BackpropOutputLayer(globalSampleIndex);
    for (int hiddenLayerIndex = int(LAYER_COUNT - 2); hiddenLayerIndex >= 0; hiddenLayerIndex--)
    {
        BackpropHiddenLayer(globalSampleIndex, hiddenLayerIndex);
    }
    BackpropInputLayer(globalSampleIndex);
}

void Backprop(const uint batchIndex)
{
    for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
    {
        const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
        Backprop(batchIndex, sampleIndex);
    }
}

ivec2 TrainSampleIndexToImageCoord(const uint trainSampleIndex)
{
    const uint y = trainSampleIndex / TRAIN_WIDTH;
    const uint x = trainSampleIndex % TRAIN_WIDTH;
    const ivec2 imageCoord = ivec2(x, y);
    return imageCoord;
}

void CalcError(const uint batchIndex, const uint sampleIndex)
{
    const uint trainSampleIndex = (batchIndex * BATCH_SIZE) + sampleIndex;
    const uint errorIndex = TRAIN_OUTPUT_NEURONS_INDEX + (trainSampleIndex * 3);

    const vec3 target = imageLoad(nrcNeuralRayTargetImage, TrainSampleIndexToImageCoord(trainSampleIndex)).xyz;
    trainNeurons[errorIndex + 0] -= target.x;
    trainNeurons[errorIndex + 1] -= target.y;
    trainNeurons[errorIndex + 2] -= target.z;
    // TODO: other error
}

void CalcError(const uint batchIndex)
{
    for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
    {
        const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
        CalcError(batchIndex, sampleIndex);
    }
}

void main()
{
    const uint batchIndex = gl_WorkGroupID.x;

    CalcError(batchIndex);
    subgroupBarrier();
    Backprop(batchIndex);
}